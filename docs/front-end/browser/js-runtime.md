

## runtime


### v8

*主要模块:*
- Ignition（解释器）
  - Parser（解析器）  
- TurboFan（编译器）
- Orinoco（垃圾回收）


*V8执行JavaScript代码的主要流程：*
- 编译
  - 解释执行字节码
  - 监听热点代码
  - 优化热点代码为二进制的机器代码
  - 优化生成二进制机器代码
  - 回退机制： 优化假设不再生效，回退到字节码
- 执行
  - 初始化执行环境
  - 解析JavaScript代码生成AST和作用域
  - 根据AST和作用域生成字节码


*详细流程:*
- Parser 解析器根据 Tokens 生成 AST
  - Parser 全量解析 解析立即执行的代码
    - 分析语法错误，遇到错误抛出异常
    - 输出AST，
    - 确定词法作用域
  - Per-parser 惰性解析 只解析未被执行的代码
    - 不生成AST 只确定作用域

- Ignition 解释器将 AST 转换为字节码，并解释执行
  - 字节码
  - 介于机器码和源码之间的中间码
    - 比机器码抽象 轻量
    - 需要直译器转译后才能成为机器码
  - why 机器码执行快 但是占内存大
- TurboFan 编译器负责将热点函数优化编译为机器指令执行；
  - 对热点函数做出一些进一步优化此代码的假设，并生成优化后的机器码
  - 如果假设失败，则退回到解释器，使用字节码重新编译
  - 假设？ 动态类型，起初 a + b为number，后面的类型不同 需要转换 


*token* 词法单元 如:
```
var a = 2;
[
    {
        type: 'keyword',
        value: 'var'
    },
    {
        type: 'identifier',
        value: 'a'
    }
]
```

*编译类型*
- 提前编译/静态编译（AOT）
- 动态编译（JIT）


> https://segmentfault.com/a/1190000040045584


### V8 相关优化 




- 采用字节码
  - 字节码的作用
    - 相对于机器码，内存小
    - 更快的启动速度
      - 生成字节码速度快于生成机器码， 结合惰性编译，提高启动速度
    - 跨平台
- 三层编译
  - 解释器
    - 生成字节码
  - 编译器
    - 生成机器码
  - 优化器 对热点代码进行优化
    - 优化机器码
- 隐藏类
  - 提升对象属性访问速度
  - 通过隐藏类，将对象的属性存储在固定的偏移量上
  - 假设
    - 对象的属性是固定的，不会动态添加或删除
- 内联缓存: 加速运算
  - 监听每个函数的执行过程，将监听数据写入到一个反馈向量表中
  - 这些监听包括 load store call
  - 缩短对象属性的查找路径，提升执行效率
- 快属性
  - 通过隐藏类，将对象的属性存储在固定的偏移量上
  - 通过快属性，提升对象属性的访问速度

### stack_heap

stack: 
  - 特性: 连续空间 先进后出
  - 管理函数调用，表示函数的调用栈
  - 在栈上分配资源和销毁资源的速度非常快
    - 栈空间是连续的，分配空间和销毁空间只需要移动下指针就可以了
    - 切换函数上下文时只要更改指针

heap: 
  - 存放在堆空间中的数据是不要求连续存放的
  - 可以在任何时候分配和释放它

### 内联缓存


内联缓存:
  js引用中用来提高属性访问性能的优化手段
  缓存对象属性访问的结果

原理:
  - 缓存访问
    - 首次访问某个对象属性时，会记录这个缓存的位置
  - 优化后续访问
    - 后续访问直接使用之前缓存信息
  - 类型优化
    - 

### 隐藏类

用于优化属性访问的手段，


### 快对象 慢对象

对象的key 分为 排序属性 常规属性  

快对象：
  - v8中高效存储方式，属性被紧密的排列在内存中
  - 属性访问快，可直接计算出属性在内存中的位置
  - 优化
    - 内联缓存 隐藏类 机制， 优化了对对象属性的频繁访问

慢对象
  - 属性存储在hash中，访问较慢
  - 处理灵活

快->慢：
  - 频繁的删除属性
  - 添加太多的属性
  - 频繁修改属性
  - 不规则的属性访问 (.[] 动态key)
  - 使用特定的属性名 (使用可以被解释为数组树荫的属性名)



### 快数组 慢数组

处理原理:
  - 类型统一: 如果统一类型， v8会进行优化
  - 元素的存储
  - 转换为慢数组的操作
  - 数组方法的优化

快 -> 慢
  - 稀疏数组
  - 非索引属性
  - 混合类型
  - 频繁删除

反向
  - 密集操作
  - 触发优化


## map set 


## all


js 设计思想
  - scheme 函数是一等公民
  - self 原型继承机制
  - java 类型系统 垃圾回收
  - C 语法


编译方式 
  - 解释执行
  - 编译执行
  - JIT just in time动态编译技术 混合执行

01. v8执行js的主要流程:
  - 初始化基础环境
  - 解析源码生成AST和作用域
  - 依据 AST 和作用域生成字节码
  - 解释执行字节码
  - 监听热点代码
  - 优化热点代码为二进制的机器代码
  - 饭优化生成的二进制机器代码

02. 函数即对象: 函数是一种特殊的对象 -> 一等公民
  - 函数对象添加两个隐藏属性
    - name 函数名称，匿名函数为 anonymous
    - code 函数代码，以字符串的形式存储在内存中， 当执行时会取出code属性值 
  - 特殊 -> 被调用，需关联相关的执行上下文 

03. 快属性 & 慢属性 
  v8存储对象时，并没有采用字典的存储方式，出于性能考虑
  分为两种属性，采用两个线性数据结构存储 
    - 常规属性: 字符串属性 properties
    - 排序属性: 数字属性 elements
  其中V8采用了一个权衡策略加快属性查找效率，将部分常规属性存储到对象本身，即 快属性 
    - 线性结构查找快， 但是大量添加删除慢，隐藏数量限制默认10
    - 当存在反复添加或删除属性的操作，v8会将线性存储经济为非线性存储模式
  delete
    - 对象属性频繁增加、删除时，浏览器可能多次调整对象的存储模式，导致性能下降
  
04. 函数表达式
  在编译阶段，会执行变量提升

05. 原型链
  - `__proto__` 会造成性能问题
  - `new` 操作符 创建对象 绑定原型 绑定this 执行函数
  - 

06. 作用域链
07. 类型转换
  - 对象转换为原始属性 -> toPrimitve
    - valueof
    - toString
09. runtime
  - 构造数据存储空间: 堆空间和栈空间
    - 栈 -> 连续空间 先进后出
      - 管理函数调用
        - 函数的生命周期和函数的资源分配 符合 后进先出的 策略
        - 分配资源和销毁资源的速度非常快
          - 栈空间是连续性的，上下移动指针即可分配销毁资源
          - 上下文切换速度快
      - 上下文内容，原生类型，引用对象的地址，函数的执行状态
      - 
    - 堆 -> 内存较大 存储离散
      - 栈有容量限制，且不易于存储不定长空间数据  - 执行上下文

    - 内容
      - 变量环境 window 数据
      - 词法环境 let const 等
      - this
  - 上下文与作用域
    - 作用域 -> 抽象概念 
    - es6中， 一个全局上下文中，能存在多个作用域 

12. 延迟解析 闭包
  - 闭包
    - js 允许在函数内部定义新的函数
    - 内部函数可以访问父函数中定义的变量
    - 函数是一等公民，可以作为返回值
  - 预解析器
    - 判断当前函数是否存在语法上的错误
    - 检查是否引用了外部变量 即 闭包

  惰性编译: 提升代码启动速度

13. 字节码
  字节码作用
    <!-- - 解释器可以直接执行字节码 -->
    <!-- - 优化编译器可以将字节码编译为二进制代码，再执行二进制机器代码 -->
    - 降低了内存占用
      - 执行速度慢于机器码
    - 提升代码启动速度
      - 生成字节码速度快于生成机器码， 结合惰性编译，提高启动速度
    - 跨平台: 中间层统一处理，架构分层，降低复杂度

解释器的架构
  - 通过模拟物理机器执行字节码， 实现如 取指令、解析指令、执行制定等 指令集
  - 

隐藏类
  - 提升对象的属性访问速度引入隐藏类
  - 加速运算引入内联缓存

静态语言，可以通过偏移量来查询对象的属性值，该属性相对于对象地址的偏移值 

V8 引入 隐藏类，会为每个对象配置一个隐藏类 
  - 假设: 创建后不会添加新属性、删除属性
  - 包含所有属性，每种类型相对于对象的偏移量

多个对象公用一个隐藏类
  - 减少创建次数 减少存储空间
  - 相同属性名称和属性个数 
实践:
  - 使用字面量初始化对象时，要保证属性的顺序是一致的
  - 尽量使用字面量一次性初始化完整对象属性
  - 尽量避免使用delete 方法

内联缓存 inline cache
  - 监听每个函数的执行过程，将监听数据写入到一个反馈向量表中
  - 这些监听包括 load store call
  - 缩短对象属性的查找路径，提升执行效率


宏任务和微任务
  - 宏任务：每次执行时，都会重新创建栈
  - 微任务: 精准的控制回调函数执行时机