

## runtime


### v8

*主要模块:*
- Parser（解析器）
- Ignition（解释器）
- TurboFan（编译器）
- Orinoco（垃圾回收）


*V8执行JavaScript代码的主要流程：*
- 编译
  - 初始化执行环境
  - 解析JavaScript代码生成AST和作用域
  - 根据AST和作用域生成字节码
- 执行
  - 解释执行字节码
  - 监听热点代码
  - 优化热点代码为二进制的机器代码
  - 优化生成二进制机器代码


*详细流程:*
- Parser 解析器根据 Tokens 生成 AST
  - Parser 全量解析 解析立即执行的代码
    - 分析语法错误，遇到错误抛出异常
    - 输出AST，
    - 确定词法作用域
  - Per-parser 惰性解析 只解析未被执行的代码
    - 不生成AST 只确定作用域

- Ignition 解释器将 AST 转换为字节码，并解释执行
  - 字节码
  - 介于机器码和源码之间的中间码
    - 比机器码抽象 轻量
    - 需要直译器转译后才能成为机器码
  - why 机器码执行快 但是占内存大
- TurboFan 编译器负责将热点函数优化编译为机器指令执行；
  - 对热点函数做出一些进一步优化此代码的假设，并生成优化后的机器码
  - 如果假设失败，则退回到解释器，使用字节码重新编译
  - 假设？ 动态类型，起初 a + b为number，后面的类型不同 需要转换 


*token* 词法单元 如:
```
var a = 2;
[
    {
        type: 'keyword',
        value: 'var'
    },
    {
        type: 'identifier',
        value: 'a'
    }
]
```

*编译类型*
- 提前编译/静态编译（AOT）
- 动态编译（JIT）


> https://segmentfault.com/a/1190000040045584


### stack_heap

stack 因为有顺序要求, 方便变量的重新赋值，和函数的执行调用 
其中变量直接存入stack中, 当调用函数时存储当前的栈顶指针(即栈帧) 
函数执行退出后, stack返回到原始点继续执行
优势:
  - 栈的结构适合表示函数调用过程
  - 在栈上分配资源和销毁资源的速度非常快
    - 栈空间是连续的，分配空间和销毁空间只需要移动下指针就可以了

heap: 
  - 存放在堆空间中的数据是不要求连续存放的
  - 可以在任何时候分配和释放它
