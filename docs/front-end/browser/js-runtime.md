

## runtime


### v8

*主要模块:*
- Ignition（解释器）
  - Parser（解析器）  
- TurboFan（编译器）
- Orinoco（垃圾回收）


*V8执行JavaScript代码的主要流程：*
- 编译
  - 解释执行字节码
  - 监听热点代码
  - 优化热点代码为二进制的机器代码
  - 优化生成二进制机器代码
  - 回退机制： 优化假设不再生效，回退到字节码
- 执行
  - 初始化执行环境
  - 解析JavaScript代码生成AST和作用域
  - 根据AST和作用域生成字节码


*详细流程:*
- Parser 解析器根据 Tokens 生成 AST
  - Parser 全量解析 解析立即执行的代码
    - 分析语法错误，遇到错误抛出异常
    - 输出AST，
    - 确定词法作用域
  - Per-parser 惰性解析 只解析未被执行的代码
    - 不生成AST 只确定作用域

- Ignition 解释器将 AST 转换为字节码，并解释执行
  - 字节码
  - 介于机器码和源码之间的中间码
    - 比机器码抽象 轻量
    - 需要直译器转译后才能成为机器码
  - why 机器码执行快 但是占内存大
- TurboFan 编译器负责将热点函数优化编译为机器指令执行；
  - 对热点函数做出一些进一步优化此代码的假设，并生成优化后的机器码
  - 如果假设失败，则退回到解释器，使用字节码重新编译
  - 假设？ 动态类型，起初 a + b为number，后面的类型不同 需要转换 


*token* 词法单元 如:
```
var a = 2;
[
    {
        type: 'keyword',
        value: 'var'
    },
    {
        type: 'identifier',
        value: 'a'
    }
]
```

*编译类型*
- 提前编译/静态编译（AOT）
- 动态编译（JIT）


> https://segmentfault.com/a/1190000040045584


### stack_heap

stack 因为有顺序要求, 方便变量的重新赋值，和函数的执行调用 
其中变量直接存入stack中, 当调用函数时存储当前的栈顶指针(即栈帧) 
函数执行退出后, stack返回到原始点继续执行
优势:
  - 栈的结构适合表示函数调用过程
  - 在栈上分配资源和销毁资源的速度非常快
    - 栈空间是连续的，分配空间和销毁空间只需要移动下指针就可以了

heap: 
  - 存放在堆空间中的数据是不要求连续存放的
  - 可以在任何时候分配和释放它

### 内联缓存


内联缓存:
  js引用中用来提高属性访问性能的优化手段
  缓存对象属性访问的结果

原理:
  - 缓存访问
    - 首次访问某个对象属性时，会记录这个缓存的位置
  - 优化后续访问
    - 后续访问直接使用之前缓存信息
  - 类型优化
    - 

### 隐藏类

用于优化属性访问的手段，


### 快对象 慢对象

对象的key 分为 排序属性 常规属性  

快对象：
  - v8中高效存储方式，属性被紧密的排列在内存中
  - 属性访问快，可直接计算出属性在内存中的位置
  - 优化
    - 内联缓存 隐藏类 机制， 优化了对对象属性的频繁访问

慢对象
  - 属性存储在hash中，访问较慢
  - 处理灵活

快->慢：
  - 频繁的删除属性
  - 添加太多的属性
  - 频繁修改属性
  - 不规则的属性访问 (.[] 动态key)
  - 使用特定的属性名 (使用可以被解释为数组树荫的属性名)



### 快数组 慢数组

处理原理:
  - 类型统一: 如果统一类型， v8会进行优化
  - 元素的存储
  - 转换为慢数组的操作
  - 数组方法的优化

快 -> 慢
  - 稀疏数组
  - 非索引属性
  - 混合类型
  - 频繁删除

反向
  - 密集操作
  - 触发优化


## map set 


