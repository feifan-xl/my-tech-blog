

## 内存管理


### stack & heap

1. 栈（Stack）内存
  - 存储内容: 原始数据类型（基本类型）和函数调用上下文。
  - 数据类型: Number, String, Boolean, null, undefined, Symbol, BigInt 等。
特点:
  - 内存分配: 在函数调用时分配，函数结束时自动释放。
  - 访问速度: 快速，采用 LIFO（后进先出）方式管理。
  - 数据大小: 占用空间较小，大小固定。
  - 存储方式: 值直接存放在栈内存中。

2. 堆（Heap）内存
  - 存储内容: 引用数据类型（复杂类型）和对象实例的数据。
  - 数据类型: Object, Array, Function, Date, RegExp 等。
特点:
  - 内存分配: 动态分配，大小不固定，需要手动管理（自动垃圾回收）。
  - 访问速度: 较慢，因为需要通过引用来访问数据。
  - 数据大小: 占用空间较大。
  - 存储方式: 引用类型的变量存放在栈中，但其实际数据存放在堆内存中，通过栈中的引用指针来访问堆中的数据。

3. 全局（Global）内存
  - 存储内容: 全局变量和全局函数。
特点:
  - 全局内存在程序运行期间一直存在，直到程序结束才会释放。
  - 由于全局内存存在于整个应用的生命周期内，过多的全局变量会导致内存占用过大，从而影响性能。


*sum*
- 原始类型数据: 存储在栈内存中，因其大小固定，分配效率高。
- 引用类型数据: 存储在堆内存中，通过栈中的引用指针访问，适合存储大数据量或复杂结构的数据。


## GC

主要采用 引用计数 & 标记-清除 算法  
V8 中采用的是代际假说

### V8 GC

sum:

V8 的 GC 系统通过分代式垃圾回收机制，有效处理了不同生命周期的对象  
新生代采用 Scavenge 算法快速回收  
而老生代通过 Mark-Sweep 和 Mark-Compact 策略优化内存管理  
结合增量和并发标记降低停顿，确保了 JavaScript 应用程序的高性能和低延迟

- 新生代 基于可达性分析,找出根引用,遍历所有跟引用,可打到的对象打上标记即为活跃对象
  - 活跃对象，经常进行垃圾回收
  - from/to 两个区域, 放入 from, 当 from 被占满时, 新生代GC启动, 算法会检查 from 空间中存活的对象并复制到 to 空间，失活对象就会摧毁,然后from to空间互换 本次gc结束
    - 晋升 
      1. 新生代中对象已经经历过一次 垃圾会送， 会被晋升到老生代空间
      2. to空间对象占比大小超过25% 为了不影响到内存分配，会将对象从新生代空间移到老生代空间中
- 老生代
    - 不活跃对象，回收频率低 标记压缩 标记清除
      - 触发时机
        - 某一个空间没有分块的时候
        - 空间中被对象超过一定限制  
        - 空间不能保证新生代中的对象移动到老生代中
      1. 标记清除算法, 且会出现内存碎片
        - 从引用根节点开始遍历 标记所有被引用的对象
        - 对 堆内存从头到尾进行线性遍历，没有标记就被回收
      2. 当碎片超国一定限制，会自动压缩算法，在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存


#### V8 的堆内存布局
V8 的堆内存分为两个主要区域：

*新生代 (New Space)*

- 存储短生命周期的小对象。 
- 它被进一步划分为两个区域：From 空间和 To 空间。对象最初分配到 From 空间，当进行垃圾回收时，存活的对象会被复制到 To 空间。此过程称为Scavenge。
经过几次 Scavenge 回收后仍然存活的对象，会被晋升到老生代。

*老生代 (Old Space)*
- 存储生命周期较长的大对象。
- 老生代采用了两种回收方式：标记-清除（Mark-Sweep）和标记-压缩（Mark-Compact

#### 回收过程 
*Scavenge(新生代垃圾回收)*

新生代内存较小且对象生命周期较短，因此 V8 采用了高效的 Scavenge 算法。每次回收只处理新生代的存活对象，将它们复制到空的 To 空间，随后清空 From 空间。新生代回收是快速且频繁的。

*Mark-Sweep & Mark-Compact（老生代垃圾回收*
- Mark-Sweep: V8 在老生代中首先标记存活的对象，随后清除未标记的对象，释放它们占用的内存。
- Mark-Compact: 如果老生代中碎片过多，V8 会触发 Mark-Compact，将存活对象向一端移动，压缩内存以释放更多连续空间。这种方式较为耗时，因此通常会结合增量标记和并发标记以减少主线程停顿时间。

#### 优化 

并行 增量 并发， 减少主线程挂起的时间
  - 并行是主线程和协助线程同时执行同样的工作
  - 增量式垃圾回收是主线程间歇性的去做少量的垃圾回收的方式
  - 并发是主线程一直执行 JavaScript，而辅助线程在后台完全的执行垃圾回收