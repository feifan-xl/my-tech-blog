



### 数据结构 

#### 堆
插入元素	O(log⁡n)O(logn)
获取堆顶元素	O(1)O(1)
删除堆顶元素	O(log⁡n)O(logn)
构建堆 (Heapify)	O(n)O(n)
堆排序	O(nlog⁡n)O(nlogn)
合并堆	O(n+m)O(n+m) 或 O(log⁡n)O(logn)
增加/减少键值	O(log⁡n)O(logn)
检查是否为空	O(1)O(1)

### 常见算法

使用场景:

小型 n2
  - 冒泡
  - 选择 不稳定
大数量级 nlogn:
  - 快排 (平均)
  - 堆排序 (空间1)
  - 归并 稳定 额外空间
一定范围 计数排序
评价 桶排序



1. 为什么快排而不是堆
  - 索引不连续
  - 堆交互次数多 
  - 对于有序数组来说 快排比建堆好

#### 插入
原理：将数组分为已排序和未排序两部分，每次从未排序部分取出一个元素插入到已排序部分的正确位置。
时间复杂度：
最好情况（已排序）：O(n)
最坏情况：O(n²)
平均情况：O(n²)
空间复杂度：O(1)
稳定性：稳定


#### 冒泡
原理：相邻元素两两比较，如果顺序错误则交换，重复多轮，直到数组有序。
时间复杂度：
最好情况（已排序）：O(n)
最坏情况：O(n²)
平均情况：O(n²)
空间复杂度：O(1)（原地排序）
稳定性：稳定


#### 快速排序（Quick Sort）
原理：选择一个基准元素，将数组划分为小于基准和大于基准的两部分，递归排序这两部分。
时间复杂度：
最好情况（均分）：O(n * log n)
最坏情况（极端不均分）：O(n²)
平均情况：O(n * log n)
空间复杂度：
原地版：O(log n)（递归栈深度）
非原地版：O(n)
稳定性：不稳定


#### 堆排序（Heap Sort）
原理：利用堆（最大堆或最小堆）结构，先构建堆，再依次取出堆顶元素。
时间复杂度：
最好、最坏、平均情况：O(n * log n)
空间复杂度：O(1)（原地排序）
稳定性：不稳定