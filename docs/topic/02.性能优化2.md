
## 性能优化

### 指标

Lighthouse Performance:
1. TTFB(time to First Byte) 浏览器接收第一个字节的时间
2. FP(first paint) 首次内容绘制，仅有一个div根节点
3. FCP(first content paint) 首次有内容的绘制，页面基本框架，但没有数据
4. FMP(first meaning paint) 首次有意义的绘制
5. TTI:Time To interactive 可交互时间
6. Long tasks:超过50ms的任务
7. LCP
8. FID

关键:
1. FCP 首次内容绘制 秒开
  - 1s 1.5s 2.5s-4s
  - 措施
    - 服务器响应时间
      - 优化资源下载时间
        - cdn http2
      - 减少资源大小
      - 缓存策略
      - 预加载 link ref=preload
    - 减少关键渲染路径资源的数量和大小
      - async  
2. LCP 
  - 2.5s-3.5s-4s
  - FCP
  - 优化渲染
    - 优化图片
    - dom结构
    - css js
      - 减少关键路径上的js css
      - 异步js
      - 内联css
    - 骨架屏
  - ssr/ssg
3. fid 首次输入延迟
  - 100ms-300ms
  - 优化js执行
  - 减少主线程工作量

测量方式
  - Perfomance Observe
  - navigate.performence

## 优化手段
多方面的过程， 涉及到从服务器配置到前端代码的全流程
  1. 资源加载优化
    + 代码压缩
    + 代码分割
    + 懒加载 预加载 cdn
  2. 图形优化
    + 格式 压缩
    + 响应式 使用不同尺寸的图片以适应不同设备尺寸 imgset 自动决策1x 2x
    + svg
  3. 服务器和网络优化
    + http2 http3
    + 减少http 请求  合并请求 
    + 启用压缩 gzip br
    + 缓存策略
  4. 渲染优化
    + 减少dom操作
    + 避免longtask
    + css优化  优化选择器， 减少重回重排
  5. web性能指标监控
    + 监控工具 lighthouse webpage chrome devtools
  6. 服务器端性能
    + lb
  7. js css架构
    + 避免阻塞 defer async
  8. 缓存
    - pwa
    - h5
    - http


### 缓存

1. appCache
  - 流程
    - 浏览器请求访问网页；
    - 服务器返回包含AppCache manifest文件的HTML页面；
    - 浏览器下载并存储manifest文件和对应的静态资源；
    - 当用户再次访问该网页时，浏览器会检查manifest文件是否发生变化。如果没有变化，则从本地缓存中加载资源；如果有变化，则重新下载更新后的资源。
  - 不支持实时数据更新、可能导致版本控制问题等
2. service worker 独立于浏览器主线程的工作线程,这是它天生具有离线的能力
  生命周期: 注册 -> 安装 -> 激活 -> idle

  缓存策略：
  1. network first
  2. cache first
  3. network only
  4. cache only
  5. Stale While Revalidate：首先尝试从缓存中获取资源，并立即返回给页面展示；同时向服务器发起请求验证该资源是否过期，如果过期则更新缓存，并在下次请求时使用新的资源。

  注意：
  1. 消息推送
  2. https


## 多图

主要策略：
  1. 图片优化: 格式 压缩
    - jpeg 有损压缩
    - png 无损 透明
    - svg
    - webp
  2. 网络传输优化: https / cdn
  3. 加载策略： 懒加载、预加载、响应式加载
    - 懒加载
      - img loading ie否
      - intersection Observer API
      - scroll resize 等事件,getBoundingClientRect API 获取元素图片距离视口顶部的距离
    - 预加载
      - `<link rel="preload" as="image" href="important.png" />`
    - 响应式
      - `<picture>
            <source srcset="hzfe-avatar-desktop.png" 


## 减少白屏时间 

### 加载慢原因及方案


1. 资源加载问题
    1. 速度慢
        - 优化加载速度
            - rel dns-prefetch
            - preconnect
            - http2
        - 预加载
            - preload
        - http请求数量多
            - 资源合并
                + sprite
                + icon svg等打包进js css
                + 小文件合并
    2. 文件大
        - 压缩
            + html 压缩 html-minifier
            + js 压缩 uglify-js
            + css 压缩 clean-css
            + gzip
            + 图片的优化
                + 图片格式
                    - jpg jpeg png webp base64
                + 图片压缩
        - 懒加载 延迟 异步
        - 分包
    3. 缓存
        - 强缓存
        - 协商缓存
        - service woker
2. 渲染问题
    + DOM 操作的优化
    + 渲染应用
        - lazy load
        - load before
        - debounce throttle
        - debounce 防抖 最后一个人说的算
        - throttle 节流 第一个人说的算
        - 异步线程
        - script 标签 defer async
        - defer 异步下载 domContentLoaded 事件前执行
        - async 异步下载 下载后执行
        - preload  预下载  下载后并不执行 需要时执行
        - prefetch 预判下载  闲时下载
    + ssr


参考: https://alienzhou.github.io/fe-performance-journey/


1. 网络延时问题
2. 资源文件体积是否过大
3. 资源是否重复发送请求
4. 加载脚本时,渲染内容堵塞了





### 主要流程

1. dns 解析优化, 提前获取 IP 地址（仅对跨域源上的请求有效）
   - `<link rel="dns-prefetch" href="" />`
   - 或者 http header Link字段
2. TCP 连接优化
    `<link href="https:" rel="preconnect" />`
3. 请求优化
    - http2 多路复用 首部压缩 二进制分帧 等 
4. 页面解析优化
    - ssr
    - 预渲染 prerender-spa-plugin
5. 资源加载优化和页面渲染优化
    - 减少资源大小
        - gzip 
        - 拆分后动态加载
    - 加快加载速度
        - cnd
        - http2
    - 预加载
        - prefetch 预请求 
        - preload
6. 接口合并 



#### prefetch preload

preload 告诉浏览器立即加载资源;
prefetch 告诉浏览器在空闲时才开始加载资源；
preload、prefetch 仅仅是加载资源，并不会“执行”;
preload、prefetch 均能设置、命中缓存；
正确使用 preload、prefetch 不会导致重复请求；



## 重排 & 重绘

### 触发
*重排*
文档结构发生变化，元素大小发生变化
- 页面的首次渲染
- 浏览器的窗口大小发生变化
- 元素的内容发生变化
- 元素的尺寸或者位置发生变化
- 元素的字体大小发生变化
- 激活CSS伪类
- 查询某些属性或者调用某些方法
- 添加或者删除可见的DOM元素


*重绘*
外观变化时 如color opacity等 不影响文档流的位置
- color、background 相关属性
- outline 相关属性：outline-color、outline-width 、text-decoration
- border-radius、visibility、box-shadow


### 解决方案

- 对 DOM 进行批量写入和读取（通过虚拟 DOM 或者 DocumentFragment 实现）。
- 避免对样式频繁操作，了解常用样式属性触发 Layout / Paint / Composite 的机制，合理使用样式。
- 合理利用特殊样式属性（如 transform: translateZ(0) 或者 will-change），将渲染层提升为合成层，开启 GPU 加速，提高页面性能。
- 使用变量对布局信息（如 clientTop）进行缓存，避免因频繁读取布局信息而触发重排和重绘。
- 需要多次重排的元素 positon 为absolute fixed， 脱离文档流，就不回影响其他元素
- display none


## 秒开
FCP 1s内

流程:
  - 容器启动
      - 容器预建
  - 白屏
  - 页面加载
      - 网络建连优化
      - 资源离线化
      - 资源分级下发
      - 资源预加载
  - FP
  - 代码执行
  - 数据获取
      - 数据预取
      - 数据缓存
  - 绘制渲染


*容器创建*
容器预建
  - 容器初始化时间不同， 冷启数百ms 热启数十ms

*资源加载*
- 网络建连优化：优化网络连接，让解析更快、链路更短
  - DNS 预解析
  - CDN
- 资源离线化：使用本地资源，直接省去网络请求
  - 更新策略: 紧急更新 轮询更新 冷启更新
  - 动态查分: bsdiff更新， 版本离线包差异
  - 签名校验: 校验资源是否被篡改
  - 在线CDN
- 资源分级下发：根据机型信息差异化分发离线包，减少包体积
  - 静态资源分级
  - 业务代码分级
- 资源预加载：在当前页面空闲状态加载下一页面资源
  - ```<link rel="prefetch" href="/images/big.jpeg" />```

*代码执行*
- JS AOT化

*数据获取*
- 数据预取, 在webview初始化的同时 获取数据 
  - 通用方案
    - scheme 参数配置
    - json维护
    - worker 运行时 
  

*数据缓存*

*绘制渲染*


## 文件压缩
- gzip lz777 hufuman 
- br brotli 字典压缩、游程编码和霍夫曼编码

Javascript 文件用 Brotli 压缩可以比 gzip 的小14%。
HTML 文件会小21%。
CSS 文件会小17%


## 框架

    - react
      - 减少不必要的重新渲染
        - 合理使用 useCallback useMemo
        - 简化 props 来提高缓存命中率
        - hooks 按需更新
        - key属性
        - 避免多层级的嵌套组件
    - vue 框架本身做了很多优化， 通常不需要手动
      - 大数据量的reactive